package swimworkoutbuilder.ui;

import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Alert;
import javafx.stage.Stage;
import swimworkoutbuilder.model.Swimmer;

public class SwimmerFormController {

    // --- FXML fields ---
    @FXML private Label lblCreateSwimmer; // not required but fine to keep
    @FXML private TextField tfFirstName;
    @FXML private TextField tfLastName;
    @FXML private TextField tfPreferredName;
    @FXML private TextField tfTeamName;
    @FXML private Button btSave;
    @FXML private Button btCancel;

    // --- Result object (null if cancelled) ---
    private Swimmer result;
    public Swimmer getResult() { return result; }

    @FXML
    private void initialize() {
        // Make keyboard-friendly:
        btSave.setDefaultButton(true);     // Enter triggers Save
        btCancel.setCancelButton(true);    // Esc triggers Cancel

        // Disable Save until required fields present:
        btSave.disableProperty().bind(
                tfFirstName.textProperty().isEmpty()
                        .or(tfLastName.textProperty().isEmpty())
        );
    }

    @FXML
    private void onSave() {
        String first = tfFirstName.getText().trim();
        String last  = tfLastName.getText().trim();

        // Double-check (belt & suspenders)
        if (first.isEmpty() || last.isEmpty()) {
            new Alert(Alert.AlertType.WARNING,
                    "First and Last name are required.").showAndWait();
            return;
        }

        String pref = tfPreferredName.getText().trim();
        String team = tfTeamName.getText().trim();

        // Construct your domain object (null for optional empties is fine)
        result = new Swimmer(
                first,
                last,
                pref.isEmpty() ? null : pref,
                team.isEmpty() ? null : team
        );

        closeWindow();


    }

    @FXML
    private void onCancel() {
        result = null; // explicitly mark as cancelled
        closeWindow();
    }

    private void closeWindow() {
        Stage stage = (Stage) btSave.getScene().getWindow();
        stage.close();
    }
}package swimworkoutbuilder.ui;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.TreeCell;
import javafx.scene.control.TreeItem;
import javafx.scene.control.TreeView;
import javafx.scene.input.ClipboardContent;
import javafx.scene.input.DragEvent;
import javafx.scene.input.Dragboard;
import javafx.scene.input.TransferMode;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.util.Callback;
import swimworkoutbuilder.model.SetGroup;
import swimworkoutbuilder.model.SwimSet;
import swimworkoutbuilder.model.Swimmer;
import swimworkoutbuilder.model.Workout;
import swimworkoutbuilder.model.enums.Course;
import swimworkoutbuilder.model.enums.Effort;
import swimworkoutbuilder.model.enums.StrokeType;
import swimworkoutbuilder.model.pacing.SeedPace;
import swimworkoutbuilder.model.units.Distance;
import swimworkoutbuilder.model.units.TimeSpan;

import java.util.Collections;
import java.util.List;

/**
 * MainView.fxml controller: renders Workout tree, supports DnD reordering,
 * and opens the Create-Swimmer dialog.
 */
public class MainViewController {

    // FXML
    @FXML private TreeView<Object> workoutTree;

    // Model
    private Workout workout;

    // Drag-and-drop state
    private TreeItem<Object> draggedItem;

    /** Inject a workout and (re)build the tree. */
    public void setWorkout(Workout workout) {
        this.workout = workout;
        rebuildTree();
    }

    @FXML private javafx.scene.control.Label lblSwimmer;

    private static String nameOrPreferred(Swimmer s) {
        if (s == null) return "â€”";
        String base = s.getFirstName() + " " + s.getLastName();
        return (s.getPreferredName() == null || s.getPreferredName().isBlank())
                ? base
                : s.getPreferredName() + " (" + base + ")";
    }

    private void setCurrentSwimmer(Swimmer s) {
        if (lblSwimmer != null) {
            lblSwimmer.setText("Swimmer: " + nameOrPreferred(s));
        }
    }

    @FXML private javafx.scene.control.ChoiceBox<Course> courseChoice;

    private void initCourseChoice() {
        if (courseChoice == null) return;
        courseChoice.getItems().setAll(Course.SCY, Course.SCM, Course.LCM);
        courseChoice.setValue(Course.SCY); // default for now
    }

    @FXML private javafx.scene.control.TextArea previewArea;

    private void refreshPreview() {
        if (previewArea == null) return;
        if (workout == null) { previewArea.setText("(no workout)"); return; }

        StringBuilder sb = new StringBuilder();
        sb.append("Workout: ").append(workout.getName()).append("\n")
                .append("Course: ").append(workout.getCourse()).append("\n\n");

        int gi = 1;
        for (SetGroup g : workout.getGroups()) {
            sb.append(gi++).append(") ").append(g.getName());
            if (g.getReps() > 1) sb.append(" x").append(g.getReps());
            if (g.getNotes() != null && !g.getNotes().isBlank()) sb.append(" â€” ").append(g.getNotes());
            sb.append("\n");

            int si = 1;
            for (SwimSet s : g.getSets()) {
                String strokeShort = (s.getStroke() == null) ? "" : s.getStroke().getShortLabel();
                sb.append("   ").append(si++).append(". ")
                        .append(s.getReps()).append("x")
                        .append(displayDistance(s)).append(" ")
                        .append(strokeShort);
                if (s.getEffort() != null) sb.append("  ").append(s.getEffort().getLabel());
                if (s.getNotes() != null && !s.getNotes().isBlank()) sb.append(" â€” ").append(s.getNotes());
                sb.append("\n");
            }
            sb.append("\n");
        }
        previewArea.setText(sb.toString());
    }

    @FXML
    private void initialize() {
        if (workoutTree == null) {
            throw new IllegalStateException("workoutTree not injected; check fx:id in MainView.fxml.");
        }

        // Demo data to make the screen useful before wiring AppState.
        Swimmer swimmer = new Swimmer("Parker", "Blackwell", "", "Indy Aquatic Masters");
        swimmer.updateSeedTime(StrokeType.FREESTYLE,
                new SeedPace(Distance.ofYards(100), TimeSpan.ofSeconds(78.0)));   // 1:18 / 100y
        swimmer.updateSeedTime(StrokeType.KICK,
                new SeedPace(Distance.ofYards(100), TimeSpan.ofSeconds(118.0)));  // 1:58 / 100y
        swimmer.updateSeedTime(StrokeType.DRILL,
                new SeedPace(Distance.ofYards(100), TimeSpan.ofSeconds(110.0)));  // 1:50 / 100y

        Workout w = new Workout(
                swimmer.getId(),
                "Test Workout",
                Course.SCY,
                "Demo workout to validate pacing and totals.",
                60
        );

        Course course = w.getCourse();
        SetGroup warmup   = new SetGroup("Warmup",   1, 1); warmup.setNotes("Focus on technique");
        SetGroup drills   = new SetGroup("Drills",   1, 2); drills.setNotes("Focus on alignment and rotation");
        SetGroup main     = new SetGroup("Main",     4, 3);
        SetGroup cooldown = new SetGroup("Cooldown", 1, 4);

        Collections.addAll(w.getGroups(), warmup, drills, main, cooldown);

        // Sets (SwimSet now takes Distance directly)
        warmup.addSet(new SwimSet(StrokeType.FREESTYLE, 1, Distance.ofYards(400), Effort.EASY,      course, "Perfect Freestyle"));
        warmup.addSet(new SwimSet(StrokeType.KICK,      4, Distance.ofYards(50),  Effort.EASY,      course, "Kick w/ streamline"));

        drills.addSet(new SwimSet(StrokeType.DRILL,     2, Distance.ofYards(50),  Effort.ENDURANCE, course, "3 strokes / 6 kicks drill"));
        drills.addSet(new SwimSet(StrokeType.FREESTYLE, 1, Distance.ofYards(50),  Effort.EASY,      course, "Apply the drill"));
        drills.addSet(new SwimSet(StrokeType.DRILL,     2, Distance.ofYards(50),  Effort.ENDURANCE, course, "Rhythm drill"));
        drills.addSet(new SwimSet(StrokeType.FREESTYLE, 1, Distance.ofYards(50),  Effort.EASY,      course, "Apply the drill"));

        main.addSet(new SwimSet(StrokeType.FREESTYLE,   4, Distance.ofYards(50),  Effort.RACE_PACE, course, "USRPT style"));
        main.addSet(new SwimSet(StrokeType.FREESTYLE,   1, Distance.ofYards(50),  Effort.EASY,      course, "Active recovery"));

        cooldown.addSet(new SwimSet(StrokeType.FREESTYLE, 4, Distance.ofYards(50), Effort.EASY, course, "Silent swimming"));

        setCurrentSwimmer(swimmer);          // show the current swimmer in the right sidebar
        initCourseChoice();                  // populate the choicebox
        if (courseChoice != null) {
            courseChoice.setValue(w.getCourse()); // keep UI in sync with demo workout (SCY/SCM/LCM)
        }
        setWorkout(w);

        workoutTree.setShowRoot(false);
        workoutTree.setCellFactory(makeCellFactory());
    }

    /** Build tree items from the workout model. */
    private void rebuildTree() {
        TreeItem<Object> root = new TreeItem<>("ROOT"); // hidden
        if (workout != null) {
            for (SetGroup g : workout.getGroups()) {
                TreeItem<Object> gItem = new TreeItem<>(g);
                for (SwimSet s : g.getSets()) {
                    gItem.getChildren().add(new TreeItem<>(s));
                }
                gItem.setExpanded(true);
                root.getChildren().add(gItem);
            }
        }
        workoutTree.setRoot(root);
        refreshPreview();
    }

    /** Custom cells: render text + wire DnD handlers. */
    private Callback<TreeView<Object>, TreeCell<Object>> makeCellFactory() {
        return tv -> new TreeCell<>() {

            {
                // Drag start
                setOnDragDetected(e -> {
                    if (getItem() == null) return;
                    draggedItem = getTreeItem();
                    Dragboard db = startDragAndDrop(TransferMode.MOVE);
                    ClipboardContent cc = new ClipboardContent();
                    cc.putString("move");
                    db.setContent(cc);
                    e.consume();
                });

                // Drag over
                setOnDragOver(e -> {
                    if (isValidDragTarget(getTreeItem())) {
                        e.acceptTransferModes(TransferMode.MOVE);
                    }
                    e.consume();
                });

                // Drop
                setOnDragDropped(this::onDrop);
            }

            private boolean isValidDragTarget(TreeItem<Object> target) {
                return draggedItem != null && target != null && draggedItem != target;
            }

            private void onDrop(DragEvent e) {
                TreeItem<Object> target = getTreeItem();
                boolean success = false;
                if (isValidDragTarget(target)) {
                    success = handleDrop(draggedItem, target);
                }
                draggedItem = null;
                e.setDropCompleted(success);
                e.consume();
            }

            @Override
            protected void updateItem(Object value, boolean empty) {
                super.updateItem(value, empty);
                if (empty || value == null) {
                    setText(null);
                    setGraphic(null);
                    return;
                }
                if (value instanceof SetGroup g) {
                    String reps = (g.getReps() > 1) ? "  x" + g.getReps() : "";
                    setText("â–ª " + g.getName() + reps);
                } else if (value instanceof SwimSet s) {
                    String effort = (s.getEffort() != null) ? s.getEffort().getLabel() : "";
                    String strokeShort = (s.getStroke() == null) ? "" : s.getStroke().getShortLabel();
                    setText(s.getReps() + "x" + displayDistance(s) + " " + strokeShort + "  " + effort);
                } else {
                    setText(value.toString());
                }
            }
        };
    }

    /** Move the dragged item in the UI and mirror that order into the model. */
    private boolean handleDrop(TreeItem<Object> dragged, TreeItem<Object> target) {
        TreeItem<Object> oldParent = dragged.getParent();
        if (oldParent == null) return false;
        oldParent.getChildren().remove(dragged);

        if (target.getValue() instanceof SetGroup) {
            target.getChildren().add(dragged); // drop onto group => append
        } else if (target.getParent() != null) {
            int idx = target.getParent().getChildren().indexOf(target);
            target.getParent().getChildren().add(idx, dragged); // drop on set => insert before
        } else {
            return false;
        }

        syncModelFromTree();
        return true;
    }

    /** Rewrite workout groups/sets lists to match current tree order. */
    private void syncModelFromTree() {
        if (workout == null || workoutTree.getRoot() == null) return;

        List<SetGroup> groups = workout.getGroups();
        groups.clear();

        for (TreeItem<Object> gItem : workoutTree.getRoot().getChildren()) {
            if (!(gItem.getValue() instanceof SetGroup g)) continue;
            groups.add(g);

            g.getSets().clear();
            for (TreeItem<Object> sItem : gItem.getChildren()) {
                if (sItem.getValue() instanceof SwimSet s) {
                    g.getSets().add(s);
                }
            }
        }
        refreshPreview();
    }

    /** Format distance using workout course unit. */
    private String displayDistance(SwimSet s) {
        if (workout != null && workout.getCourse() == Course.SCY) {
            // display yards for SCY; snap to 25-yd lap for cleaner UI
            int yards = (int) Math.round(s.getDistancePerRep().toYards());
            int snapped = (int) Math.round(yards / 25.0) * 25;
            return snapped + "yd";
        }
        int meters = (int) Math.round(s.getDistancePerRep().toMeters());
        return meters + "m";
    }

    // --- Menu actions ---

    @FXML
    private void handleAbout(ActionEvent e) {
        new Alert(Alert.AlertType.INFORMATION,
                "SwimWorkoutBuilder\nMVP UI + pacing engine.\nÂ© 2025").showAndWait();
    }

    @FXML // allow MenuItem/Button onAction to call this
    private void handleNewSwimmer(ActionEvent e) {
        try {
            // Load the dialog UI
            var fxml = getClass().getResource("/ui/SwimmerForm.fxml");
            if (fxml == null) throw new IllegalStateException("Missing /ui/SwimmerForm.fxml");

            FXMLLoader loader = new FXMLLoader(fxml);
            Parent root = loader.load();

            // Controller gives us the result after the dialog closes
            SwimmerFormController controller = loader.getController();

            // Build a modal dialog owned by this window
            Stage owner = (Stage) workoutTree.getScene().getWindow();
            Stage dialog = new Stage();
            dialog.setTitle("Swimmer Setup");
            dialog.initOwner(owner);
            dialog.initModality(Modality.APPLICATION_MODAL);
            dialog.setResizable(false);
            dialog.setScene(new Scene(root));

            // Block here until Save/Cancel
            dialog.showAndWait();

            // Read back the result (null if user cancelled)
            var created = controller.getResult();
            if (created != null) {
                try {
                    swimworkoutbuilder.model.io.SwimmerRepository.append(created);
                } catch (Exception ex) {
                    new Alert(Alert.AlertType.ERROR, "Failed to save swimmer:\n" + ex.getMessage()).showAndWait();
                    return;
                }
                setCurrentSwimmer(created); // updates â€œSwimmer: â€¦â€ label
                new Alert(Alert.AlertType.INFORMATION,
                        "Created swimmer:\n" +
                                created.getFirstName() + " " + created.getLastName() +
                                (created.getPreferredName() != null ? " (â€œ" + created.getPreferredName() + "â€)" : "") +
                                (created.getTeamName() != null ? "\nTeam: " + created.getTeamName() : "")
                ).showAndWait();

                // TODO: AppState.setCurrentSwimmer(created); update UI as needed.
            }
        } catch (Exception ex) {
            new Alert(Alert.AlertType.ERROR,
                    "Could not open Create Swimmer form:\n" + ex.getMessage()).showAndWait();
            ex.printStackTrace();
        }
    }
}package swimworkoutbuilder.ui;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;

/**
 * A pure-JavaFX version of the Main View (no FXML).
 *
 * GOAL:
 * - Demonstrate how to build the same UI structure you designed in Scene Builder,
 *   but entirely in code. This is useful both for learning and for quick prototyping.
 *
 * LAYOUT OVERVIEW (BorderPane regions):
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ TOP:    MenuBar                                               â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ LEFT:   VBox ("Workout" label + Tree/List of items)           â”‚
 *   â”‚                                                               â”‚
 *   â”‚ CENTER: TabPane ("Set Editor" + "Preview")                    â”‚
 *   â”‚                                                               â”‚
 *   â”‚ RIGHT:  VBox -> TitledPane ("Seeds & Units") -> GridPane      â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ BOTTOM: HBox (status bar)                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */
public class MainViewCodeOnly extends Application {

    @Override
    public void start(Stage stage) {
        // Root container for the whole window. BorderPane gives us 5 regions:
        // top, left, center, right, bottom.
        BorderPane root = new BorderPane();

        // TOP: Menu bar
        MenuBar menuBar = new MenuBar();

        // "File" menu (with Close)
        Menu fileMenu = new Menu("File");
        MenuItem miClose = new MenuItem("Close");
        // simple behavior: close the window
        miClose.setOnAction(e -> stage.close());
        fileMenu.getItems().add(miClose);

        // "Edit" menu (placeholder)
        Menu editMenu = new Menu("Edit");
        editMenu.getItems().add(new MenuItem("Delete"));

        // "Help" menu (About dialog)
        Menu helpMenu = new Menu("Help");
        MenuItem miAbout = new MenuItem("About");
        miAbout.setOnAction(e ->
                new Alert(Alert.AlertType.INFORMATION,
                        "SwimWorkoutBuilder\nMVP UI + pacing engine.\nÂ© 2025").showAndWait()
        );
        helpMenu.getItems().add(miAbout);

        menuBar.getMenus().addAll(fileMenu, editMenu, helpMenu);
        root.setTop(menuBar);

        // -----------------------------
        // LEFT: Workout list/tree
        // -----------------------------
        // We use a VBox to stack a label above a list component. You can swap ListView
        // for a TreeView later when youâ€™re ready for groups/sets nesting.
        VBox leftPane = new VBox(8);                  // 8px vertical gap between children
        leftPane.setPadding(new Insets(10));          // inner padding so content isnâ€™t flush to edges
        leftPane.setPrefWidth(260);                   // give the left column a comfortable width

        Label workoutLabel = new Label("Workout");

        // Placeholder content: a list of strings.
        // Swap for a TreeView<SetGroup/SwimSet> later.
        ListView<String> workoutList = new ListView<>();
        workoutList.getItems().addAll(
                "Warmup",
                "Drills",
                "Main Set",
                "Cooldown"
        );
        // Let the list grow to fill available vertical space in the left VBox
        VBox.setVgrow(workoutList, Priority.ALWAYS);

        leftPane.getChildren().addAll(workoutLabel, workoutList);
        root.setLeft(leftPane);

        // -----------------------------
        // CENTER: Tab pane (Set Editor / Preview)
        // -----------------------------
        TabPane tabPane = new TabPane();
        tabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE); // no close buttons on tabs
        // Give the tab pane a chance to expand inside center area
        VBox centerBox = new VBox(tabPane);
        VBox.setVgrow(tabPane, Priority.ALWAYS);

        // Editor tab (placeholder content for now)
        Tab editorTab = new Tab("Set Editor", new Label("Set Editor content"));

        // Preview tab (placeholder content for now)
        Tab previewTab = new Tab("Preview", new Label("Preview content"));

        tabPane.getTabs().addAll(editorTab, previewTab);
        root.setCenter(centerBox);

        // -----------------------------
        // RIGHT: Seeds & Units panel
        // -----------------------------
        // Wrap it in a VBox for future expansion (e.g., add more panes later).
        VBox rightPane = new VBox();
        rightPane.setPadding(new Insets(10));
        rightPane.setSpacing(8);
        rightPane.setPrefWidth(260);

        // TitledPane as a section container
        TitledPane seedsUnitsPane = new TitledPane();
        seedsUnitsPane.setText("Seeds & Units");
        seedsUnitsPane.setCollapsible(false); // keep it always open in MVP

        // Grid for labels + controls
        GridPane grid = new GridPane();
        grid.setHgap(10);   // horizontal gap between columns
        grid.setVgap(8);    // vertical gap between rows

        // Optional: make column 1 (index 1) stretch a bit
        ColumnConstraints c0 = new ColumnConstraints();
        c0.setHgrow(Priority.NEVER); // label column stays natural size

        ColumnConstraints c1 = new ColumnConstraints();
        c1.setHgrow(Priority.ALWAYS); // input column can grow

        grid.getColumnConstraints().addAll(c0, c1);

        // Row 0: Course choice
        grid.add(new Label("Course:"), 0, 0);
        ChoiceBox<String> courseChoice = new ChoiceBox<>();
        courseChoice.getItems().addAll("SCY (25y)", "SCM (25m)", "LCM (50m)");
        courseChoice.getSelectionModel().selectFirst();
        grid.add(courseChoice, 1, 0);

        // Row 1: Units (Yards/Meters)
        grid.add(new Label("Units:"), 0, 1);
        ToggleGroup unitsGroup = new ToggleGroup();
        RadioButton yards = new RadioButton("Yards");
        yards.setToggleGroup(unitsGroup);
        yards.setSelected(true); // default
        RadioButton meters = new RadioButton("Meters");
        meters.setToggleGroup(unitsGroup);

        // Put the radios side-by-side
        HBox unitBox = new HBox(10, yards, meters);
        // Make the unit box consume any extra width to avoid clipping text
        HBox.setHgrow(unitBox, Priority.ALWAYS);
        grid.add(unitBox, 1, 1);

        // (Optional) you can add seed entry fields here later, for each stroke, etc.

        seedsUnitsPane.setContent(grid);
        rightPane.getChildren().add(seedsUnitsPane);
        root.setRight(rightPane);

        // -----------------------------
        // BOTTOM: Status bar
        // -----------------------------
        HBox statusBar = new HBox();
        statusBar.setPadding(new Insets(6, 10, 6, 10));
        statusBar.setStyle("-fx-background-color: -fx-control-inner-background; "
                + "-fx-border-color: -fx-box-border; -fx-border-width: 1 0 0 0;");
        statusBar.getChildren().add(new Label("Ready"));
        root.setBottom(statusBar);

        // -----------------------------
        // SCENE + STAGE
        // -----------------------------
        // Scene ties the node tree to the window. Set an initial size that feels roomy.
        Scene scene = new Scene(root, 1000, 700);
        stage.setScene(scene);
        stage.setTitle("Workout Builder (Code-Only Demo)");
        stage.show();

        // (Optional) If you want to react to units choice in MVP:
        unitsGroup.selectedToggleProperty().addListener((obs, oldT, newT) -> {
            if (newT instanceof RadioButton rb) {
                System.out.println("Units changed to: " + rb.getText());
            }
        });
    }

    public static void main(String[] args) {
        launch(args);
    }
}package swimworkoutbuilder.ui;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Modality;
import javafx.stage.Stage;

import swimworkoutbuilder.model.Swimmer;

import java.net.URL;

public class SwimmerFormLauncher extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        // 1) Locate FXML
        URL fxml = getClass().getResource("/ui/SwimmerForm.fxml");
        if (fxml == null) {
            throw new IllegalStateException("FXML not found at /ui/SwimmerForm.fxml");
        }

        // 2) Load FXML + controller
        FXMLLoader loader = new FXMLLoader(fxml);
        Parent root = loader.load(); // must load before getController()
        SwimmerFormController controller = loader.getController(); // <-- get the controller

        // 3) Build modal dialog
        Stage dialog = new Stage();
        dialog.setTitle("Swimmer Setup");
        dialog.initOwner(primaryStage);                 // owner can be invisible
        dialog.initModality(Modality.APPLICATION_MODAL);
        dialog.setScene(new Scene(root));
        dialog.setResizable(false);

        // 4) Show dialog and wait for Save/Cancel to close it
        dialog.showAndWait();

        // 5) Read the result from the controller
        Swimmer created = controller.getResult();       // <-- singular method name
        if (created != null) {
            System.out.println("User created swimmer: " + created);
        } else {
            System.out.println("User cancelled swimmer creation");
        }

        // 6) Exit app (since we only launched a dialog)
        Platform.exit();
    }

    public static void main(String[] args) {
        launch(args);
    }
}package swimworkoutbuilder.SandBox;

import javafx.animation.*;
import javafx.application.*;
import javafx.beans.binding.*;
import javafx.geometry.*;
import javafx.scene.*;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.scene.paint.*;
import javafx.scene.shape.*;
import javafx.stage.*;
import javafx.util.*;

public class FanAnimation extends Application {
    public void start(Stage primaryStage) {

        // Create an buttonBox with buttons, centered
        HBox  buttonBox = new HBox(8);
        buttonBox.setAlignment(Pos.CENTER);

        Button btPause = new Button("Pause");
        Button btResume = new Button("Resume");
        Button btReverse = new Button("Reverse");
        Button btHigh = new Button("High");
        Button btMedium = new Button("Medium");
        Button btLow = new Button("Low");

        // make all buttons equal size and share space if window grows
        for (Button b : new Button[]{btPause, btResume, btReverse, btHigh, btMedium, btLow}) {
            HBox.setHgrow(b, Priority.ALWAYS);
            b.setMaxWidth(Double.MAX_VALUE);
        }

        buttonBox.getChildren().addAll(btPause, btResume, btReverse, btHigh, btMedium, btLow);

        // Layout
        BorderPane pane = new BorderPane();
        BorderPane.setMargin(buttonBox, new Insets(10, 10, 15, 10));
        pane.setBottom(buttonBox);

        // Fan and animation
        FanPane fan = new FanPane();
        pane.setCenter(fan);
        Timeline animation = new Timeline(new KeyFrame(Duration.millis(25), e -> fan.move()));
        animation.setCycleCount(Timeline.INDEFINITE);
        animation.setRate(1);
        animation.play();

        // Button actions
        btPause.setOnAction(e -> animation.pause());
        btResume.setOnAction(e -> animation.play());
        btReverse.setOnAction(e -> fan.reverse());
        btHigh.setOnAction(e -> animation.setRate(4));
        btMedium.setOnAction(e -> animation.setRate(2));
        btLow.setOnAction(e -> animation.setRate(1));

        // Scene setup
        Scene scene = new Scene(pane);
        primaryStage.setTitle("Fan Animation");
        primaryStage.setScene(scene);
        primaryStage.sizeToScene();
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
// FanPane: draws and animates the fan
class FanPane extends Pane {
    private final Circle circle = new Circle();
    private final Arc[] arc = new Arc[4];
    private final double BLADE_ANGLE = 35;

    private double startAngle = 30;
    private double increment = 5;

    public FanPane() {
        // Add circle: center bound to pane center; radius bound to min(w, h) * 0.45
        setPrefSize(220, 220); // or any reasonable starting size
        circle.setStroke(Color.BLACK);
        circle.setFill(Color.WHITE);
        circle.centerXProperty().bind(widthProperty().divide(2));
        circle.centerYProperty().bind(heightProperty().divide(2));
        circle.radiusProperty().bind(Bindings.min(widthProperty(), heightProperty()).multiply(0.45));
        getChildren().add(circle);

        // draw the fan blades (arcs): same center; radii bound to circle radius * 0.9
        for (int i = 0; i < 4; i++) {
            Arc a = new Arc();
            a.setType(ArcType.ROUND);
            a.setFill(Color.RED);

            a.centerXProperty().bind(circle.centerXProperty());
            a.centerYProperty().bind(circle.centerYProperty());
            a.radiusXProperty().bind(circle.radiusProperty().multiply(0.9));
            a.radiusYProperty().bind(circle.radiusProperty().multiply(0.9));

            a.startAngleProperty().set(startAngle + i * 90);
            a.setLength(BLADE_ANGLE);

            arc[i] = a;
            getChildren().add(a);
        }
    }


    public void move() {
        // update the start angle
        setStartAngle(startAngle + increment);
    }

    public void reverse() {
        increment = -increment;
    }
    public void setStartAngle(double angle) {
        this.startAngle = angle;
        for (int i = 0; i < 4; i++) {
            arc[i].setStartAngle(startAngle + i * 90);
        }
    }
}
package swimworkoutbuilder.ai;

import com.openai.client.OpenAIClient;
import com.openai.client.okhttp.OpenAIOkHttpClient;
import com.openai.models.ChatModel;
import com.openai.models.chat.completions.ChatCompletion;
import com.openai.models.chat.completions.ChatCompletionCreateParams;

public class CodeReviewer {
    private final OpenAIClient client = OpenAIOkHttpClient.fromEnv();

    public String review(String code, String question) {
        ChatCompletionCreateParams params = ChatCompletionCreateParams.builder()
                .model(ChatModel.GPT_4_1)
                .addUserMessage("Here is some Java code:\n\n" + code +
                        "\n\nQuestion: " + question)
                .build();

        ChatCompletion completion = client.chat().completions().create(params);
        return completion.choices().get(0).message().content().orElse("(no reply)");
    }

    public static void main(String[] args) {
        String code = "public class Hello { public static void main(String[] args){ System.out.println(\"Hi\"); } }";
        String question = "Whatâ€™s wrong with this code?";
        System.out.println(new CodeReviewer().review(code, question));
    }
}package swimworkoutbuilder;

import swimworkoutbuilder.model.*;
import swimworkoutbuilder.model.enums.*;
import swimworkoutbuilder.model.pacing.DefaultPacePolicy;
import swimworkoutbuilder.model.pacing.PacePolicy;
import swimworkoutbuilder.model.utils.WorkoutPrinter;
import swimworkoutbuilder.model.units.Distance;

import java.util.Collections;

/**
 * Main class for running the SwimWorkoutBuilder application to test functionality behind the UI.
 * 1) Create a Swimmer
 * 2) Define seed times for the swimmer
 * 3) Create a Workout
 * 4) Create SetGroups and SwimSets
 * 5) Print the workout using the default policy to calculate pace and print to console
 */
public class Main {
    public static void main(String[] args) {
        System.out.println("ðŸŠ SwimWorkoutBuilder is running!");

        // 1) Swimmer
        Swimmer swimmer = new Swimmer("Parker", "Blackwell", "", "Indy Aquatic Masters");

        // 2) Seeds (per 100 yards, in seconds)
        swimmer.updateSeed100Y(StrokeType.FREESTYLE, 78.0); // 1:18 / 100y
        swimmer.updateSeed100Y(StrokeType.KICK,      118.0); // 1:58 / 100y
        swimmer.updateSeed100Y(StrokeType.DRILL,     110.0); // 1:50 / 100y

        // 3) Workout
        Workout w = new Workout(
                swimmer.getId(),
                "Test Workout",
                Course.SCY,
                "Demo workout to validate pacing and totals.",
                60 // default rest between groups (seconds)
        );

        Course course = w.getCourse(); // convenience

        // 4) Groups
        SetGroup warmup   = new SetGroup("Warmup", 1, 1);
        warmup.setNotes("Focus on technique");

        SetGroup drills   = new SetGroup("Drills", 1, 2);
        drills.setNotes("Focus on alignment and rotation");

        SetGroup main     = new SetGroup("Main", 4, 3);
        SetGroup cooldown = new SetGroup("Cooldown", 1, 4);

        Collections.addAll(w.getGroups(), warmup, drills, main, cooldown);

        // 5) Sets (SwimSet now takes Distance directly)
        warmup.addSet(new SwimSet(StrokeType.FREESTYLE, 1, Distance.ofYards(400), Effort.EASY,      course, "Perfect Freestyle"));
        warmup.addSet(new SwimSet(StrokeType.KICK,      4, Distance.ofYards(50),  Effort.EASY,      course, "Kick w/ streamline"));

        drills.addSet(new SwimSet(StrokeType.DRILL,     2, Distance.ofYards(50),  Effort.ENDURANCE, course, "3 strokes / 6 kicks drill"));
        drills.addSet(new SwimSet(StrokeType.FREESTYLE, 1, Distance.ofYards(50),  Effort.EASY,      course, "Apply the drill"));
        drills.addSet(new SwimSet(StrokeType.DRILL,     2, Distance.ofYards(50),  Effort.ENDURANCE, course, "Rhythm drill"));
        drills.addSet(new SwimSet(StrokeType.FREESTYLE, 1, Distance.ofYards(50),  Effort.EASY,      course, "Apply the drill"));

        main.addSet(new SwimSet(StrokeType.FREESTYLE,   4, Distance.ofYards(50),  Effort.RACE_PACE, course, "USRPT style"));
        main.addSet(new SwimSet(StrokeType.FREESTYLE,   1, Distance.ofYards(50),  Effort.EASY,      course, "Active recovery"));

        cooldown.addSet(new SwimSet(StrokeType.FREESTYLE,4, Distance.ofYards(50),  Effort.EASY,      course, "Silent swimming"));

        // (Optional) Example of adding equipment to a set
        // main.getSets().get(0).addEquipment(Equipment.FINS);

        // 6) Print full workout using policy
        PacePolicy policy = new DefaultPacePolicy();
        WorkoutPrinter.printWorkout(w, swimmer, policy);
    }
}package swimworkoutbuilder.model;

import swimworkoutbuilder.model.enums.Course;
import swimworkoutbuilder.model.units.Distance;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

/**
 * A structured swim workout designed for a specific swimmer.
 * MVP: container + metadata. All timing math is handled by PacePolicy/WorkoutPrinter.
 */
public class Workout {

    // Identity & metadata
    private final UUID id;
    private UUID swimmerId;                 // the swimmer this workout is for
    private String name;                    // e.g., "Tuesday Threshold"
    private Course course;                  // SCY, SCM, or LCM
    private String notes;                   // optional workout-level notes (theme, focus)

    // Defaults (used by printer between groups)
    private int defaultRestBetweenGroupsSeconds = 0;  // applied between consecutive groups if group override not set

    // Contents
    private final List<SetGroup> groups = new ArrayList<>();

    // --- Constructors ---

    public Workout(UUID swimmerId, String name, Course course) {
        this.id = UUID.randomUUID();
        this.swimmerId = Objects.requireNonNull(swimmerId, "swimmerId");
        this.name = Objects.requireNonNull(name, "name");
        this.course = Objects.requireNonNull(course, "course");
    }

    public Workout(UUID swimmerId, String name, Course course, String notes, int defaultRestBetweenGroupsSeconds) {
        this.id = UUID.randomUUID();
        this.swimmerId = Objects.requireNonNull(swimmerId, "swimmerId");
        this.name = Objects.requireNonNull(name, "name");
        this.course = Objects.requireNonNull(course, "course");
        this.notes = notes;
        this.defaultRestBetweenGroupsSeconds = Math.max(0, defaultRestBetweenGroupsSeconds);
    }

    // --- Basic getters/setters ---

    public UUID getId() { return id; }

    public UUID getSwimmerId() { return swimmerId; }
    public void setSwimmerId(UUID swimmerId) { this.swimmerId = Objects.requireNonNull(swimmerId, "swimmerId"); }

    public String getName() { return name; }
    public void setName(String name) { this.name = Objects.requireNonNull(name, "name"); }

    public Course getCourse() { return course; }
    public void setCourse(Course course) { this.course = Objects.requireNonNull(course, "course"); }

    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }

    public int getDefaultRestBetweenGroupsSeconds() { return defaultRestBetweenGroupsSeconds; }
    public void setDefaultRestBetweenGroupsSeconds(int seconds) {
        this.defaultRestBetweenGroupsSeconds = Math.max(0, seconds);
    }

    // --- Groups management (ordered & mutable) ---

    public List<SetGroup> getGroups() { return groups; }

    public int getGroupCount() { return groups.size(); }

    public void addSetGroup(SetGroup group) {
        if (group != null) groups.add(group);
    }

    public void insertSetGroup(int index, SetGroup group) {
        if (group == null) return;
        groups.add(index, group); // will throw if index invalid (MVP: fail fast)
    }

    public SetGroup removeSetGroup(int index) {
        return groups.remove(index);
    }

    public void moveGroup(int fromIndex, int toIndex) {
        if (fromIndex == toIndex) return;
        SetGroup g = groups.remove(fromIndex); // throws if fromIndex invalid
        groups.add(toIndex, g);                // throws if toIndex invalid
    }

    public void swapGroups(int i, int j) {
        if (i == j) return;
        SetGroup a = groups.get(i); // throws if invalid
        SetGroup b = groups.get(j);
        groups.set(i, b);
        groups.set(j, a);
    }

    // --- Distance helpers ---

    /**
     * NEW: Sum of group distances for a single pass across all groups, as a Distance.
     * Uses existing group meter totals and wraps them as Distance for now.
     * (Once SetGroup is Distance-aware, this method can sum canonically without conversion.)
     */
    public Distance singlePassDistance() {
        return Distance.ofMeters(singlePassDistanceMeters());
    }

    /**
     * NEW: Total distance including group repeats, as a Distance.
     */
    public Distance totalDistance() {
        return Distance.ofMeters(totalDistanceMeters());
    }

    /** Sum of group distances for a single pass across all groups (meters). */
    @Deprecated
    public int singlePassDistanceMeters() {
        int sum = 0;
        for (SetGroup g : groups) {
            sum += g.singlePassDistanceMeters();
        }
        return sum;
    }

    /** Total distance including group repeats (meters). */
    @Deprecated
    public int totalDistanceMeters() {
        int sum = 0;
        for (SetGroup g : groups) {
            sum += g.totalDistanceMeters();
        }
        return sum;
    }

    @Override
    public String toString() {
        return "Workout{" +
                "id=" + id +
                ", swimmerId=" + swimmerId +
                ", name='" + name + '\'' +
                ", course=" + course +
                ", groups=" + groups.size() +
                ", defaultRestBetweenGroupsSeconds=" + defaultRestBetweenGroupsSeconds +
                (notes != null && !notes.isBlank() ? ", notes='" + notes + '\'' : "") +
                '}';
    }
}package swimworkoutbuilder.model;

import swimworkoutbuilder.model.enums.StrokeType;
import swimworkoutbuilder.model.pacing.SeedPace;   // <-- add this
import swimworkoutbuilder.model.units.Distance;    // only if you use the overloads
import swimworkoutbuilder.model.units.TimeSpan;    // only if you use the overloads

import java.util.EnumMap;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

/**
 * Represents a swimmer using the workout builder.
 * Stores identity and baseline seed paces (per stroke). Each seed is a {@link SeedPace}
 * that preserves the original entry (distance+unit and time) and caches canonical speed (m/s).
 *
 * Ergonomic overloads let you set seeds as "per-100y" or "per-100m" without extra boilerplate.
 */
public class Swimmer {
    private final UUID id;
    private String firstName;
    private String lastName;
    private String preferredName;   // optional / nullable
    private String teamName;        // optional / nullable
    private final Map<StrokeType, SeedPace> seedPaces = new EnumMap<>(StrokeType.class);

    // --- Constructors ---

    public Swimmer(String firstName, String lastName) {
        this(UUID.randomUUID(), firstName, lastName, null, null);
    }

    public Swimmer(String firstName, String lastName, String preferredName, String teamName) {
        this(UUID.randomUUID(), firstName, lastName, preferredName, teamName);
    }

    // UUID-aware constructor (e.g., repository load)
    public Swimmer(UUID id, String firstName, String lastName, String preferredName, String teamName) {
        if (id == null) throw new IllegalArgumentException("id must not be null");
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.preferredName = preferredName;
        this.teamName = teamName;
    }

    // --- Identity ---

    public UUID getId() { return id; }
    public String getFirstName() { return firstName; }
    public String getLastName() { return lastName; }
    public String getPreferredName() { return preferredName; }
    public String getTeamName() { return teamName; }

    public void setFirstName(String firstName) { this.firstName = firstName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    public void setPreferredName(String preferredName) { this.preferredName = preferredName; }
    public void setTeamName(String teamName) { this.teamName = teamName; }

    // --- Seeds (per stroke) ---

    /** Returns the baseline seed for the given stroke, or null if not set. */
    public SeedPace getSeedTime(StrokeType stroke) {
        return seedPaces.get(stroke);
    }

    /** Creates or replaces the baseline seed for the given stroke. */
    public void updateSeedTime(StrokeType stroke, SeedPace seed) {
        Objects.requireNonNull(stroke, "stroke");
        Objects.requireNonNull(seed,   "seed");
        seedPaces.put(stroke, seed);
    }

    /** Convenience: set a seed defined as "per 100 yards" in <b>seconds</b>. */
    public void updateSeed100Y(StrokeType stroke, double secondsPer100Y) {
        updateSeedTime(stroke,
                new SeedPace(Distance.ofYards(100), TimeSpan.ofSeconds(secondsPer100Y)));
    }

    /** Convenience: set a seed defined as "per 100 meters" in <b>seconds</b>. */
    public void updateSeed100M(StrokeType stroke, double secondsPer100M) {
        updateSeedTime(stroke,
                new SeedPace(Distance.ofMeters(100), TimeSpan.ofSeconds(secondsPer100M)));
    }

    /** Convenience: explicit distance + time overload (e.g., 200m in 120.0s). */
    public void updateSeedTime(StrokeType stroke, Distance seedDistance, TimeSpan seedTime) {
        Objects.requireNonNull(seedDistance, "seedDistance");
        Objects.requireNonNull(seedTime,     "seedTime");
        updateSeedTime(stroke, new SeedPace(seedDistance, seedTime));
    }

    public boolean hasSeed(StrokeType stroke) { return seedPaces.containsKey(stroke); }

    public void clearSeed(StrokeType stroke) { seedPaces.remove(stroke); }

    /** Removes all seeds for this swimmer. */
    public void clearAllSeeds() { seedPaces.clear(); }

    // --- Derived helpers (nice to have) ---

    /** Returns canonical speed (m/s) for a stroke, or NaN if no seed set. */
    public double speedMps(StrokeType stroke) {
        SeedPace s = seedPaces.get(stroke);
        return (s == null) ? Double.NaN : s.speedMps();
    }

    /** Returns true if all four primary strokes have seeds set. */
    public boolean hasCoreSeeds() {
        return hasSeed(StrokeType.FREESTYLE)
                && hasSeed(StrokeType.BACKSTROKE)
                && hasSeed(StrokeType.BREASTSTROKE)
                && hasSeed(StrokeType.BUTTERFLY);
    }

    @Override
    public String toString() {
        return "Swimmer(" +
                "id=" + id + ", " +
                "name=" + firstName + " " + lastName + ", " +
                "preferredName=" + (preferredName == null ? "" : preferredName) + ", " +
                "teamName=" + (teamName == null ? "" : teamName) + ", " +
                "seedPaces=" + seedPaces +
                ')';
    }
}package swimworkoutbuilder.model;

import swimworkoutbuilder.model.enums.Course;
import swimworkoutbuilder.model.enums.Effort;
import swimworkoutbuilder.model.enums.Equipment;
import swimworkoutbuilder.model.enums.StrokeType;
import swimworkoutbuilder.model.units.Distance;

import java.util.EnumSet;
import java.util.Set;

/**
 * Represents a single training set (e.g., "8 Ã— 50 FREESTYLE @ ENDURANCE").
 *
 * Responsibilities:
 *  â€¢ Stores the essential attributes of one set:
 *      - stroke, reps, distance per rep (exact, via Distance value object),
 *      - effort level, optional notes, course context (SCY/SCM/LCM),
 *      - optional equipment modifiers.
 *  â€¢ Validates and normalizes distance so it is always a legal multiple of the pool length.
 *      - If an invalid distance is given (e.g., 75 in a 50m pool), it is snapped
 *        to the nearest valid multiple using ROUND UP.
 *  â€¢ Keeps the model consistent for pace calculations; pacing is computed elsewhere.
 *
 * Design notes:
 *  â€¢ Distances are stored with exact internal units (0.0001 m) in the Distance value object.
 *  â€¢ Course is required; distance normalization depends on it.
 *  â€¢ Equipment is modeled as an EnumSet so multiple training aids can be applied together.
 */
public class SwimSet {

    private StrokeType stroke;
    private int reps;
    private Distance distancePerRep; // exact (canonical stored inside Distance)
    private Effort effort;
    private String notes;            // optional
    private Course course;           // pool context for this set

    // Equipment used for this set (optional; defaults to none)
    private Set<Equipment> equipment = EnumSet.noneOf(Equipment.class);

    // --- Constructors ---

    public SwimSet(StrokeType stroke,
                   int reps,
                   Distance distancePerRep,
                   Effort effort,
                   Course course,
                   String notes) {
        if (reps < 1) throw new IllegalArgumentException("reps must be >= 1");
        if (distancePerRep == null || distancePerRep.rawUm4() <= 0)
            throw new IllegalArgumentException("distancePerRep must be > 0");
        if (course == null) throw new IllegalArgumentException("course must not be null");

        this.stroke = stroke;
        this.reps = reps;
        this.effort = effort;
        this.notes = (notes == null ? "" : notes);
        this.course = course;

        // Snap distance to a legal multiple of the pool length (ROUND UP).
        this.distancePerRep = snapUpToCourseMultiple(distancePerRep, course);
    }

    // Convenience (no notes)
    public SwimSet(StrokeType stroke,
                   int reps,
                   Distance distancePerRep,
                   Effort effort,
                   Course course) {
        this(stroke, reps, distancePerRep, effort, course, "");
    }

    // --- Getters / Setters ---

    public StrokeType getStroke() { return stroke; }
    public void setStroke(StrokeType stroke) { this.stroke = stroke; }

    public int getReps() { return reps; }
    public void setReps(int reps) {
        if (reps < 1) throw new IllegalArgumentException("reps must be >= 1");
        this.reps = reps;
    }

    public Distance getDistancePerRep() { return distancePerRep; }
    public void setDistancePerRep(Distance distancePerRep) {
        if (distancePerRep == null || distancePerRep.rawUm4() <= 0)
            throw new IllegalArgumentException("distancePerRep must be > 0");
        this.distancePerRep = snapUpToCourseMultiple(distancePerRep, this.course);
    }

    public Effort getEffort() { return effort; }
    public void setEffort(Effort effort) { this.effort = effort; }

    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = (notes == null ? "" : notes); }

    public Course getCourse() { return course; }
    public void setCourse(Course course) {
        if (course == null) throw new IllegalArgumentException("course must not be null");
        this.course = course;
        // Re-snap existing distance to the new course
        this.distancePerRep = snapUpToCourseMultiple(this.distancePerRep, this.course);
    }

    public Set<Equipment> getEquipment() { return equipment; }
    public void setEquipment(Set<Equipment> equipment) {
        this.equipment = (equipment == null) ? EnumSet.noneOf(Equipment.class) : EnumSet.copyOf(equipment);
    }
    public void addEquipment(Equipment e) {
        if (e == null) return;
        if (equipment == null) equipment = EnumSet.noneOf(Equipment.class);
        equipment.add(e);
    }
    public void removeEquipment(Equipment e) {
        if (e == null || equipment == null) return;
        equipment.remove(e);
    }
    public boolean hasEquipment(Equipment e) {
        return equipment != null && equipment.contains(e);
    }

    @Override
    public String toString() {
        return "SwimSet{" +
                "stroke=" + stroke +
                ", reps=" + reps +
                ", distancePerRep=" + distancePerRep +
                ", effort=" + effort +
                ", course=" + course +
                (equipment != null && !equipment.isEmpty() ? ", equipment=" + equipment : "") +
                (notes != null && !notes.isBlank() ? ", notes='" + notes + '\'' : "") +
                '}';
    }

    // --- Helpers ---

    /**
     * Snap a distance UP to the nearest legal multiple of the pool length for the given course.
     * Exact integer math on canonical units (0.0001 m), no floating-point drift.
     */
    private static Distance snapUpToCourseMultiple(Distance distance, Course course) {
        Distance poolLen = course.getLength();
        long d = distance.rawUm4();
        long p = poolLen.rawUm4();
        if (p <= 0) return distance; // safety

        long multiples = d / p;
        if (d % p != 0) multiples++; // round UP
        long snapped = Math.max(p, Math.multiplyExact(multiples, p)); // at least one pool length

        // Preserve the user's preferred display unit for the set distance
        return Distance.ofCanonicalUm4(snapped, distance.displayUnit());
    }
}package swimworkoutbuilder.model.enums;

import java.util.Set;

/**
 * Equipment factors adjust target pace calculations to account for training aids.
 * Multipliers are applied as part of the pace policy, and multiple pieces of
 * equipment can be combined (multipliers multiplied together).
 *
 * Typical defaults (tunable):
 *  - FINS:       0.88 (faster, strong kick propulsion)
 *  - PADDLES:    0.96 (slightly faster, more pull power)
 *  - PULL_BUOY:  1.05 (slower overall pace, less kick drive)
 *  - SNORKEL:    0.99 (neutral to slightly slower)
 *  - DRAG_SOCKS: 1.15 (slower due to resistance)
 *  - PARACHUTE:  1.20 (significantly slower due to resistance)
 */
public enum Equipment {
    FINS("Fins", 0.88),
    PADDLES("Paddles", 0.96),
    PULL_BUOY("Pull Buoy", 1.05),
    SNORKEL("Snorkel", 0.99),
    DRAG_SOCKS("Drag Socks", 1.15),
    PARACHUTE("Parachute", 1.20);

    private final String label;
    private final double multiplier;

    Equipment(String label, double multiplier) {
        this.label = label;
        this.multiplier = multiplier;
    }

    /** User-friendly label for UI display. */
    public String getLabel() { return label; }

    /** Performance multiplier for this equipment. */
    public double multiplier() { return multiplier; }

    /**
     * Compute the combined multiplier for a set of equipment items.
     * If the set is null or empty, returns 1.0 (neutral).
     */
    public static double combinedMultiplier(Set<Equipment> equipment) {
        if (equipment == null || equipment.isEmpty()) return 1.0;
        double m = 1.0;
        for (Equipment e : equipment) {
            if (e != null) m *= e.multiplier;
        }
        return m;
    }

    @Override
    public String toString() { return label; }
}package swimworkoutbuilder.model.enums;

import swimworkoutbuilder.model.units.Distance;

/**
 * DistanceFactors provides multipliers to adjust target pace
 * depending on repeat distance. Short reps are faster than seed,
 * longer reps trend slower.
 *
 * Distances are stored as exact Distance values (canonical 0.0001 m units).
 * Multipliers are applied during pace calculations.
 *
 * To do: add a fallback calculation for distances outside the buckets.
 */
public enum DistanceFactors {
    D25 (Distance.ofMeters(25),    0.92),
    D50 (Distance.ofMeters(50),    0.94),
    D75 (Distance.ofMeters(75),    0.97),
    D100(Distance.ofMeters(100),   1.00),
    D200(Distance.ofMeters(200),   1.05),
    D400(Distance.ofMeters(400),   1.10),
    D800(Distance.ofMeters(800),   1.15),
    D1500(Distance.ofMeters(1500), 1.20);

    private final Distance distance;
    private final double multiplier;

    DistanceFactors(Distance distance, double multiplier) {
        this.distance = distance;
        this.multiplier = multiplier;
    }

    /** Returns the canonical distance (exact) this factor is defined for. */
    public Distance distance() { return distance; }

    /** Returns the multiplier applied at this distance. */
    public double multiplier() { return multiplier; }

    /**
     * Get the pace multiplier for an arbitrary distance.
     * Uses distance buckets (rounded up to the nearest defined distance)
     * to approximate performance trends.
     */
    public static double forDistance(Distance d) {
        long meters = Math.round(d.toMeters());
        if (meters <= 25)   return D25.multiplier;
        if (meters <= 50)   return D50.multiplier;
        if (meters <= 75)   return D75.multiplier;
        if (meters <= 100)  return D100.multiplier;
        if (meters <= 200)  return D200.multiplier;
        if (meters <= 400)  return D400.multiplier;
        if (meters <= 800)  return D800.multiplier;
        return D1500.multiplier; // default for anything longer
    }

    @Override
    public String toString() {
        return Math.round(distance.toMeters()) + "m (" + multiplier + ")";
    }
}package swimworkoutbuilder.model.enums;

import swimworkoutbuilder.model.units.Distance;

/**
 * Represents the type of swimming course (i.e., pool length).
 *
 * SCY = Short Course Yards (25 yards)
 * SCM = Short Course Meters (25 meters)
 * LCM = Long Course Meters (50 meters)
 *
 * v2: added performance multiplier used by pace calculation.
 * SC pools have more turns, which means more push-offs and more underwaters as a percentage
 * of the distance compared to an LC pool.
 *
 * Typical defaults:
 *  - SCY: 1.00 (25y: more turns, more underwater as a percentage of distance)
 *  - SCM: 1.04 (25m: underwater % slightly less than SCY)
 *  - LCM: 1.07 (50m: half as many turns as SCY/SCM, less underwater vs. surface swimming)
 */
public enum Course {
    SCY("Short Course Yards", Distance.ofYards(25), CourseUnit.YARDS, 1.00),
    SCM("Short Course Meters", Distance.ofMeters(25), CourseUnit.METERS, 1.04),
    LCM("Long Course Meters", Distance.ofMeters(50), CourseUnit.METERS, 1.07);

    private final String description;
    private final Distance length;      // pool length as exact Distance
    private final CourseUnit unit;
    private final double multiplier;    // performance multiplier

    Course(String description, Distance length, CourseUnit unit, double multiplier) {
        this.description = description;
        this.length = length;
        this.unit = unit;
        this.multiplier = multiplier;
    }

    public String getDescription() { return description; }

    /** Returns the pool length as a Distance (exact, e.g., 25 yards or 25 meters). */
    public Distance getLength() { return length; }

    public CourseUnit getUnit() { return unit; }

    /** Performance multiplier applied in pace calculations. */
    public double multiplier() { return multiplier; }

    @Override
    public String toString() {
        return description + " (" + length.toString() + ")" + " (multiplier=" + multiplier + ")";
    }
}package swimworkoutbuilder.model.enums;

/**
 * Effort levels are essential for creating goal-oriented structured workouts.
 *
 * v1: enum name + long description
 * v2: added label and short description for UI
 * v3: added paceMultiplier (scales seed /100) and restAllowanceSec (legacy interval hook)
 *
 * Notes in v4:
 *  â€¢ paceMultiplier is still included for legacy/future experimentation, but DefaultPacePolicy
 *    primarily drives rest/interval with distance Ã— effort curves (restPercent).
 *  â€¢ Rest allowance (seconds) is retained but currently unused in canonical policy; left as a hook.
 */
public enum Effort {
    EASY(
            "Easy",
            "Warmup/cooldown, active recovery",
            "Active recovery, technique focus, light pace, minimal exertion. Used between challenging sets or for warm-up/cool-down.",
            1.55, 20
    ),
    ENDURANCE(
            "Endurance",
            "Aerobic, steady cruise pace",
            "Aerobic steady, cruise pace, able to sustain for long durations (~10+ minutes) with little to moderate rest. Develops aerobic capacity.",
            1.35, 15
    ),
    THRESHOLD(
            "Threshold",
            "Strong, controlled pace",
            "Lactate threshold effort. Strong but controlled pace, just below race intensity. Can sustain repeats of 3â€“5 minutes with short rest.",
            1.22, 10
    ),
    RACE_PACE(
            "Race Pace",
            "Target competition pace",
            "Target competition pace. Swim at the exact speed of your goal event to develop pacing and race endurance. Effort is high, but repeatable.",
            1.05, 30
    ),
    VO2_MAX(
            "VO2 Max",
            "Very intense, near max",
            "High aerobic power effort. Very intense pace, near maximum oxygen uptake, sustainable for ~1â€“3 minutes. Builds maximum aerobic capacity.",
            1.00, 40
    ),
    SPRINT(
            "Sprint",
            "All-out, maximal speed",
            "All-out, maximal effort. Short bursts (â‰¤25â€“50m) at top speed, long recovery required. Focus on power, explosiveness, and pure speed.",
            0.95, 60
    );

    // v1: label and long description
    private final String label;
    private final String longDescription;

    // v2: short description for UI
    private final String shortDescription;

    // v3: multipliers and rest allowance
    private final double paceMultiplier;   // scales seed /100 for this effort
    private final int restAllowanceSec;    // seconds added to goal for interval

    Effort(String label, String shortDescription, String longDescription,
           double paceMultiplier, int restAllowanceSec) {
        this.label = label;
        this.shortDescription = shortDescription;
        this.longDescription = longDescription;
        this.paceMultiplier = paceMultiplier;
        this.restAllowanceSec = restAllowanceSec;
    }

    public String getLabel() { return label; }
    public String getShortDescription() { return shortDescription; }
    public String getLongDescription() { return longDescription; }

    /**
     * Legacy multiplier applied to seed pace per 100 for this effort level.
     * In canonical math we still use this for initial tuning,
     * but DefaultPacePolicy combines it with DistanceFactors and rest curves.
     */
    public double paceMultiplier() { return paceMultiplier; }

    /** Legacy rest allowance (seconds). Not currently used in DefaultPacePolicy. */
    public int restAllowanceSec() { return restAllowanceSec; }

    @Override
    public String toString() { return label; }
}package swimworkoutbuilder.model.enums;

import java.util.HashMap;
import java.util.Map;

/**
 * Enumeration of supported swimming stroke types.
 *
 * <p>Each stroke has:</p>
 * <ul>
 *   <li>a canonical enum constant</li>
 *   <li>a user-friendly full label</li>
 *   <li>a short label (common shorthand for UI)</li>
 *   <li>optional aliases for parsing input</li>
 * </ul>
 *
 * <p>This allows flexible parsing of user input (e.g. "Free", "Fr",
 * "Fly", or "IM") without losing the canonical form, while also giving
 * you compact output in workouts.</p>
 */
public enum StrokeType {
    FREESTYLE("Freestyle", "Free", new String[]{"Fr"}),
    BACKSTROKE("Backstroke", "Back", new String[]{"Bk"}),
    BREASTSTROKE("Breaststroke", "Breast", new String[]{"Br"}),
    BUTTERFLY("Butterfly", "Fly", new String[]{}),
    INDIVIDUAL_MEDLEY("Individual Medley", "IM", new String[]{}),
    KICK("Kick", "Kick", new String[]{}),   // was FREE_KICK
    DRILL("Drill", "Drill", new String[]{});

    private final String label;
    private final String shortLabel;
    private final String[] aliases;

    StrokeType(String label, String shortLabel, String[] aliases) {
        this.label = label;
        this.shortLabel = shortLabel;
        this.aliases = aliases;
    }

    /** User-friendly label for UI or reports. */
    public String getLabel() {
        return label;
    }

    /** Short label for compact UI (tables, previews, etc.). */
    public String getShortLabel() {
        return shortLabel;
    }

    /** Aliases (shorthand names) for parsing input. */
    public String[] getAliases() {
        return aliases.clone();
    }

    @Override
    public String toString() {
        return label;
    }

    // --- Static parsing support ---

    private static final Map<String, StrokeType> LOOKUP = new HashMap<>();

    static {
        for (StrokeType type : values()) {
            LOOKUP.put(type.name().toUpperCase(), type);        // enum name
            LOOKUP.put(type.label.toUpperCase(), type);         // full label
            LOOKUP.put(type.shortLabel.toUpperCase(), type);    // short label
            for (String alias : type.aliases) {
                LOOKUP.put(alias.toUpperCase(), type);
            }
        }
    }

    /**
     * Parse a string into a StrokeType, using enum names, labels, short labels, or aliases.
     * @param text user input (e.g. "Free", "Fly", "IM")
     * @return matching StrokeType, or null if none matched
     */
    public static StrokeType fromString(String text) {
        if (text == null) return null;
        return LOOKUP.get(text.trim().toUpperCase());
    }
}package swimworkoutbuilder.model.enums;

/**
 * CourseUnit = Pool length unit of measure
 */
public enum CourseUnit {
    YARDS,
    METERS
}
package swimworkoutbuilder.model.io;

import swimworkoutbuilder.model.Swimmer;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Repository for managing swimmers.
 *
 * <p>This class provides persistence and retrieval of {@link Swimmer} data.
 * Swimmer profiles are stored in a simple CSV file located in the application's data directory
 * The repository ensures that the folder and file exist before attempting read/write operations.
 *
 * <p><b>Responsibilities:</b>
 * <ul>
 *     <li> Load swimmers from CSV into memory.</li>
 *     <li> Save swimmers back to CSV.</li>
 *     <li>Create the necessary directory and file if they do not exist.</li>
 *     <li> Very simple CSV escaping (quotes only).</li>
 * </ul>
 *
 * <p><b>Design Notes:</b>
 * <ul>
 *     <li>CSV storage is deliberately minimal to reduce dependencies. Future versions may support JSON or database-backed persistence.</li>
 *     <li>Escaping is basic and intended only to handle commas and quotes in swimmer names - it is not intended as a general CSV solution.</li>
 * </ul>
 *
 * <p><b>Usage Example:</b>
 * <pre>{@code
 * SwimmerRepository repo = SwimmerRepository.getInstance();
 * List<Swimmer> swimmers = repo.loadAll();
 *
 * Swimmer parker = new Swimmer("Parker", "Blackwell", " ", "Indy Aquatic Masters");
 * swimmers.add(parker);
 *
 * repo.saveAll(swimmers);
 * }</pre>
 *
 * @author parkerblackwell
 * @version 1.0
 * @since 2025-10-03
 * @see Swimmer
 */
public final class SwimmerRepository {

    // private no-arg constructor: can't create instances of SwimmerRepository, "SwimmerRepositor repo = new SwimmerRepository()" is not allowed.
    private SwimmerRepository() {}

   // ----- File management helpers
    /** Builds the path based on the user's system ~/.swimworkoutbuilder/swimmers.csv */
    public static Path dataDir() {
        String home = System.getProperty("user.home");         // e.g., /Users/parkerblackwell
        return Paths.get(home, ".swimworkoutbuilder");  // e.g., /Users/parkerblackwell/.swimworkoutbuilder
    }
    private static Path swimmersFile() {                        //  e.g., /Users/parkerblackwell/.swimworkoutbuilder/swimmers.csv
        return dataDir().resolve("swimmers.csv");         // .resolve appends "swimmers.csv" to the path,
    }

    /** Helper method to ensure data directory and swimmers.csv exists.  If not, create with header row. */
    private static void ensureFileReady() throws IOException {
        Files.createDirectories(dataDir());
        Path f = swimmersFile();
        if (Files.notExists(f)) {
            Files.write(f, Collections.singletonList("id,first,last,preferred,team"),
                    StandardCharsets.UTF_8, StandardOpenOption.CREATE);
        }
    }

    // ----- CSV 'escaping' helpers: q -> writing to CSV, uq -> reading from CSV */
    /** Wrap a string in quotes and replace quotes inside a string with double quotes. */
    private static String q(String s) {
        if (s == null) return "";
        String esc = s.replace("\"", "\"\"");
        return "\"" + esc + "\"";
    }
    /** Unescape CSV: strip surrounding quotes and restore doubled "" to ". */
    private static String uq(String s) {
        if (s == null) return null;
        if (s.length() >= 2 && s.startsWith("\"") && s.endsWith("\"")) {
            s = s.substring(1, s.length() - 1).replace("\"\"", "\"");
        }
        return s.isEmpty() ? null : s;
    }

    /** Parses one line of CSV text into columns.  Handles commas inside quotes (e.g., "Smith, Jr."). */
    private static String[] parseCsvLine(String line) {
        List<String> cols = new ArrayList<>();
        StringBuilder cur = new StringBuilder();
        boolean inQuote = false;

        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if (c == '"') {
                inQuote = !inQuote;
                cur.append(c);
            } else if (c == ',' && !inQuote) {
                cols.add(cur.toString());   // finish one column
                cur.setLength(0);           // reset buffer
            } else {
                cur.append(c);
            }
        }
        cols.add(cur.toString());           // add last column
        return cols.toArray(new String[0]);
    }

    // ----- Public API
    /** Load swimmers from CSV into memory (ignore invalid lines). */
    public static List<Swimmer> loadAll() throws IOException {
        ensureFileReady();      // Folder / file exists, if not create it

        /** Use BufferedReader to read the file line-by-line. */
        try (BufferedReader reader = Files.newBufferedReader(swimmersFile(), StandardCharsets.UTF_8)) {
            List<String> lines = reader.lines().collect(Collectors.toList());
            if (lines.isEmpty()) return Collections.emptyList();

            List<Swimmer> out = new ArrayList<>();
            for (int i = 0; i < lines.size(); i++) {
                String line = lines.get(i).trim();
                if (line.isEmpty()) continue;
                if (i == 0 && line.startsWith("id,")) continue; // skip header
                if (line.startsWith("#")) continue;             // allow comments

                String[] cols = parseCsvLine(line);
                if (cols.length < 5) {
                    System.err.println("WARNING: Skipping invalid line in swimmers.csv: " + line);
                    continue;
                }
                UUID id = UUID.fromString(uq(cols[0].trim()));
                String first = uq(cols[1]);
                String last = uq(cols[2]);
                String preferred = uq(cols[3]);
                String team = uq(cols[4]);
                if (first == null || last == null) {
                    System.err.println("WARNING: Skipping invalid line in swimmers.csv: " + line);
                    continue;
                }
                out.add(new Swimmer(id, first, last, preferred, team));  // Use UUID-aware constructor
            }
            return out;
        }
    }

    /** Append a swimmer to the CSV. */
    public static void append(Swimmer s) throws IOException {
        ensureFileReady();
        String line = String.join(",",
                q(s.getId().toString()),
                q(s.getFirstName()),
                q(s.getLastName()),
                q(s.getPreferredName()),
                q(s.getTeamName())
        );
        Files.write(
                swimmersFile(),
                Collections.singletonList(line + System.lineSeparator()),
                StandardCharsets.UTF_8,
                StandardOpenOption.APPEND
        );
    }
}
package swimworkoutbuilder.model.utils;

import swimworkoutbuilder.model.SetGroup;
import swimworkoutbuilder.model.SwimSet;
import swimworkoutbuilder.model.Swimmer;
import swimworkoutbuilder.model.Workout;
import swimworkoutbuilder.model.enums.Course;
import swimworkoutbuilder.model.pacing.PacePolicy;
import swimworkoutbuilder.model.units.Distance;

public final class WorkoutPrinter {
    private WorkoutPrinter() {}

    public static void printWorkout(Workout w, Swimmer swimmer, PacePolicy policy) {
        boolean displayYards = (w.getCourse() == Course.SCY);
        String unitLabel = displayYards ? "yd" : "m";

        System.out.println("==================================================");
        String swimmerName = (swimmer.getFirstName() + " " + swimmer.getLastName()).trim();
        String shortId = swimmer.getId().toString().substring(0, 8);
        System.out.printf("Swimmer: %s  (id=%s)%n", swimmerName, shortId);
        System.out.printf("Workout: %s  [%s]%n", w.getName(), w.getCourse());
        if (w.getNotes() != null && !w.getNotes().isBlank()) {
            System.out.println("Notes:   " + w.getNotes());
        }
        System.out.println();

        long workoutSwimSeconds = 0;
        long workoutIntraRestSeconds = 0;
        long workoutBetweenGroupRestSeconds = 0;
        long workoutDisplayDistance = 0; // yards for SCY, meters otherwise

        System.out.println("Groups (" + w.getGroups().size() + "):");
        int groupIndex = 0;

        for (SetGroup g : w.getGroups()) {
            groupIndex++;
            int groupReps = Math.max(1, g.getReps());

            System.out.printf("  %d) %s", g.getOrder(), g.getName());
            if (groupReps > 1) System.out.print("  x" + groupReps);
            System.out.println();
            if (g.getNotes() != null && !g.getNotes().isBlank()) {
                System.out.println("     - " + g.getNotes());
            }

            long singlePassGroupSwimSec = 0;
            long singlePassGroupIntraRestSec = 0;
            long singlePassGroupDisplayDist = 0; // yards or meters per display rules

            int idx = 1;
            for (SwimSet s : g.getSets()) {
                int reps = s.getReps();
                Distance rep = s.getDistancePerRep();

                // Per-rep display distance (snap to lap size for SCY display)
                int repDisplayDist = displayYards
                        ? snapToLapYards((int) Math.round(rep.toYards()))
                        : (int) Math.round(rep.toMeters());

                String strokeShort = (s.getStroke() == null) ? "" : s.getStroke().getShortLabel();

                System.out.printf("     %d. %dx%d%s %-14s %-12s%n",
                        idx++,
                        reps,
                        repDisplayDist, unitLabel,
                        strokeShort,
                        (s.getEffort() != null ? s.getEffort().getLabel() : "")
                );

                for (int r = 1; r <= reps; r++) {
                    double goal  = policy.goalSeconds(w, s, swimmer, r);
                    int interval = policy.intervalSeconds(w, s, swimmer, r);
                    int rest     = policy.restSeconds(w, s, swimmer, r);

                    singlePassGroupSwimSec      += Math.round(goal);
                    singlePassGroupIntraRestSec += rest;

                    System.out.printf("         #%d  goal %s | on %s | rest %s%n",
                            r, mmss(goal), mmss(interval), mmss(rest));
                }

                if (s.getNotes() != null && !s.getNotes().isBlank()) {
                    System.out.println("         note: " + s.getNotes());
                }

                // Add display distance for this set to the group display total
                singlePassGroupDisplayDist += (long) reps * repDisplayDist;
            }

            long groupDisplayTotal = singlePassGroupDisplayDist * groupReps;
            long groupSwimSecondsTotal = singlePassGroupSwimSec * groupReps;
            long groupIntraRestTotal   = singlePassGroupIntraRestSec * groupReps;

            workoutDisplayDistance      += groupDisplayTotal;
            workoutSwimSeconds          += groupSwimSecondsTotal;
            workoutIntraRestSeconds     += groupIntraRestTotal;

            System.out.printf("     Group totals: distance=%d%s  swim=%s  rest=%s  total=%s%n",
                    groupDisplayTotal, unitLabel,
                    mmss(groupSwimSecondsTotal),
                    mmss(groupIntraRestTotal),
                    mmss(groupSwimSecondsTotal + groupIntraRestTotal));

            // Between-group rest (use group's override if present, else workout default)
            int restAfter = (g.getRestAfterGroupSec() > 0)
                    ? g.getRestAfterGroupSec()
                    : w.getDefaultRestBetweenGroupsSeconds();

            if (groupIndex < w.getGroups().size() && restAfter > 0) {
                workoutBetweenGroupRestSeconds += restAfter;
                System.out.println("     (+" + mmss(restAfter) + " rest after group)");
            }

            System.out.println();
        }

        long workoutTotalSeconds = workoutSwimSeconds + workoutIntraRestSeconds + workoutBetweenGroupRestSeconds;

        System.out.println("Totals:");
        System.out.println("  swim time:          " + mmss(workoutSwimSeconds));
        System.out.println("  intra-set rest:     " + mmss(workoutIntraRestSeconds));
        System.out.println("  between-group rest: " + mmss(workoutBetweenGroupRestSeconds));
        System.out.println("  ------------------------------------");
        System.out.println("  workout total:      " + mmss(workoutTotalSeconds));
        System.out.println("  total distance:     " + workoutDisplayDistance + " " + unitLabel);
        System.out.println("==================================================");
        System.out.println();
    }

    // snap yard counts to pool lap increments for SCY (25 yd)
    private static int snapToLapYards(int yards) {
        int lap = 25;
        int laps = Math.round(yards / (float) lap);
        return laps * lap;
    }

    private static String mmss(double seconds) {
        long s = Math.max(0, Math.round(seconds));
        return String.format("%d:%02d", s / 60, s % 60);
    }
}package swimworkoutbuilder.model.utils;

import com.openai.client.OpenAIClient;
import com.openai.client.okhttp.OpenAIOkHttpClient;
import com.openai.models.ChatModel;
import com.openai.models.chat.completions.ChatCompletion;
import com.openai.models.chat.completions.ChatCompletionCreateParams;

public class TestOpenAI {
    public static void main(String[] args) {
        String key = System.getenv("OPENAI_API_KEY");
        if (key == null || key.isBlank()) {
            System.err.println("âŒ OPENAI_API_KEY not set. Add it to Run Config or ~/.zshrc");
            System.exit(2);
        }
        OpenAIClient client = OpenAIOkHttpClient.fromEnv();

        ChatCompletionCreateParams params = ChatCompletionCreateParams.builder()
                .model(ChatModel.GPT_4_1_MINI) // API name for â€œGPT-5 Miniâ€ in ChatGPT
                .addUserMessage("Say hello from SwimWorkoutBuilder!")
                .build();

        ChatCompletion completion = client.chat().completions().create(params);
        System.out.println("ðŸ”¹ OpenAI replied:");
        completion.choices().forEach(c -> c.message().content().ifPresent(System.out::println));
    }
}package swimworkoutbuilder.model.pacing;

import swimworkoutbuilder.model.units.Distance;
import swimworkoutbuilder.model.units.TimeSpan;

import java.util.Objects;

/**
 * Baseline pace for a given distance and time.
 * Stores the original distance/time and derives canonical speed (m/s).
 *
 * Minimal by design to align with current policy and callers.
 */
public final class SeedPace {
    private final Distance originalDistance;  // e.g., 100y or 100m
    private final TimeSpan time;              // time for that distance
    private final double speedMps;            // meters/second (0 if time==0)

    /**
     * Create a seed pace from a measured distance and time.
     * @param originalDistance distance swum (e.g., 100y or 100m)
     * @param time time to complete that distance
     */
    public SeedPace(Distance originalDistance, TimeSpan time) {
        this.originalDistance = Objects.requireNonNull(originalDistance, "originalDistance");
        this.time             = Objects.requireNonNull(time, "time");
        long ms = this.time.toMillis();
        this.speedMps = (ms <= 0L) ? 0.0 : (this.originalDistance.toMeters() / (ms / 1000.0));
    }

    /** The original baseline distance (e.g., 100y or 100m). */
    public Distance getOriginalDistance() { return originalDistance; }

    /** The measured time for the original distance. */
    public TimeSpan getTime() { return time; }

    /** Canonical speed in meters/second (0 if time==0). */
    public double speedMps() { return speedMps; }

    @Override
    public String toString() {
        return "SeedPace{" +
                "originalDistance=" + originalDistance +
                ", time=" + time +
                ", speedMps=" + String.format("%.3f", speedMps) +
                '}';
    }
}package swimworkoutbuilder.model.pacing;

import swimworkoutbuilder.model.SwimSet;
import swimworkoutbuilder.model.Swimmer;
import swimworkoutbuilder.model.Workout;

/**
 * Strategy interface for turning sets + seeds into concrete timing.
 *
 * Policies define how goal times, rests, and intervals are computed from:
 *  â€¢ the workout context (course, modifiers),
 *  â€¢ the swimmer's seed pace,
 *  â€¢ and the set definition (stroke, reps, distance, effort, equipment).
 */
public interface PacePolicy {

    /** Goal time (seconds) for a single rep (not the send-off). */
    double goalSeconds(Workout workout, SwimSet set, Swimmer swimmer, int repIndex);

    /**
     * Interval/send-off (seconds) for a single rep.
     * MVP rule: interval = round(goal) + rest.
     */
    int intervalSeconds(Workout workout, SwimSet set, Swimmer swimmer, int repIndex);

    /** Rest after the rep (seconds). MVP rule: derived from Effort Ã— distance ratio. */
    int restSeconds(Workout workout, SwimSet set, Swimmer swimmer, int repIndex);

    /**
     * Optional short label for UI/printer (e.g., "rest :20").
     * Implementations may format this however they wish.
     */
    String timingLabel(Workout workout, SwimSet set, Swimmer swimmer, int repIndex);
}package swimworkoutbuilder.model.pacing;

import swimworkoutbuilder.model.SwimSet;
import swimworkoutbuilder.model.Swimmer;
import swimworkoutbuilder.model.Workout;
import swimworkoutbuilder.model.enums.DistanceFactors;
import swimworkoutbuilder.model.enums.Effort;
import swimworkoutbuilder.model.enums.Equipment;
import swimworkoutbuilder.model.enums.StrokeType;

import java.util.Set;

/**
 * Multiplier-based MVP policy for computing goal, interval, and rest.
 *
 * Core design:
 *  â€¢ Canonical math is done with speed (m/s) derived from the swimmer's SeedPace.
 *  â€¢ Goal time (seconds) = (repDistanceMeters / speedMps) Ã— compositeFactor
 *      where compositeFactor = effort Ã— distanceBucket Ã— course Ã— equipment Ã— fatigue(=1.0 for MVP)
 *  â€¢ Rest time (seconds) = rounded(goal) Ã— restPercent(effort, r),
 *      where r = (rep distance) / (seed's original distance)
 *  â€¢ Interval rounded to nearest 5 seconds.
 *
 * Notes:
 *  â€¢ DistanceFactors accepts Distance directly and buckets by nominal meters (25/50/75/...).
 *  â€¢ No floating-point unit conversions inside core math; Distance is exact internally.
 */
public class DefaultPacePolicy implements PacePolicy {

    // Flip to false to silence debug printing
    private static final boolean DEBUG = false;

    @Override
    public double goalSeconds(Workout workout, SwimSet set, Swimmer swimmer, int repIndex) {
        if (workout == null || set == null || swimmer == null)
            throw new IllegalArgumentException("workout, set, and swimmer are required.");

        // 1) Seed (canonical speed)
        StrokeType stroke = set.getStroke();
        SeedPace seed = swimmer.getSeedTime(stroke);
        if (seed == null) throw new IllegalStateException("Missing seed for stroke: " + stroke);
        double speedMps = seed.speedMps(); // canonical

        // 2) Multipliers
        Effort effort = set.getEffort();
        double mEffort  = (effort == null) ? 1.0 : effort.paceMultiplier();
        double mDist    = usesDistanceFactor(effort) ? DistanceFactors.forDistance(set.getDistancePerRep()) : 1.0;
        double mCourse  = workout.getCourse().multiplier();
        double mEquip   = equipmentProduct(set.getEquipment());
        double mFatigue = 1.0; // hook for future

        // 3) Distance in meters (canonical), compute goal
        double repMeters = set.getDistancePerRep().toMeters();
        double goal = (repMeters / speedMps) * mEffort * mDist * mCourse * mEquip * mFatigue;

        if (DEBUG) {
            System.out.printf(
                    "[DEBUG] %s rep #%d goal: (%.2fm / %.4f m/s) Ã— %.2f(effort) Ã— %.2f(dist) Ã— %.2f(course) Ã— %.2f(equip) Ã— %.2f(fatigue) = %.2fs%n",
                    stroke, repIndex + 1,
                    repMeters, speedMps, mEffort, mDist, mCourse, mEquip, mFatigue, goal
            );
        }
        return goal;
    }

    @Override
    public int restSeconds(Workout workout, SwimSet set, Swimmer swimmer, int repIndex) {
        if (workout == null || set == null || swimmer == null)
            throw new IllegalArgumentException("workout, set, and swimmer are required.");

        // Round goal first, then compute rest as a percentage
        int goalRounded = (int) Math.round(goalSeconds(workout, set, swimmer, repIndex));

        // r = (rep distance) / (seed's original distance)
        SeedPace seed = swimmer.getSeedTime(set.getStroke());
        if (seed == null) throw new IllegalStateException("Missing seed for " + set.getStroke());

        double repMeters  = set.getDistancePerRep().toMeters();
        double seedMeters = seed.getOriginalDistance().toMeters(); // e.g., 100y or 100m (in meters)
        double r = distanceRatio(repMeters, seedMeters);

        double pct = restPercent(set.getEffort(), r);
        int rest = (int) Math.round(goalRounded * pct);

        if (DEBUG) {
            System.out.printf("[DEBUG-REST] r=%.2f (rep=%.2fm / seed=%.2fm), effort=%s, rest%%=%.1f%% -> rest=%ds%n",
                    r, repMeters, seedMeters, set.getEffort(), pct * 100.0, rest);
        }
        return Math.max(0, rest);
    }

    @Override
    public int intervalSeconds(Workout workout, SwimSet set, Swimmer swimmer, int repIndex) {
        int goalRounded = (int) Math.round(goalSeconds(workout, set, swimmer, repIndex));
        int rest = restSeconds(workout, set, swimmer, repIndex);
        int interval = goalRounded + rest;
        int rounded = roundToNearest5(interval);
        if (DEBUG && rounded != interval) {
            System.out.printf("[DEBUG-INT] interval %ds -> rounded to %ds%n", interval, rounded);
        }
        return rounded;
    }

    @Override
    public String timingLabel(Workout workout, SwimSet set, Swimmer swimmer, int repIndex) {
        int rest = restSeconds(workout, set, swimmer, repIndex);
        return "rest :" + rest;
    }

    // --- helpers ---

    private static boolean usesDistanceFactor(Effort e) {
        if (e == null) return false;
        switch (e) {
            case THRESHOLD:
            case RACE_PACE:
            case VO2_MAX:
            case SPRINT:
                return true;
            case EASY:
            case ENDURANCE:
            default:
                return false;
        }
    }

    private static double equipmentProduct(Set<Equipment> equipment) {
        if (equipment == null || equipment.isEmpty()) return 1.0;
        double m = 1.0;
        for (Equipment eq : equipment) {
            if (eq != null) m *= eq.multiplier();
        }
        return m;
    }

    /** Distance ratio r = rep / seedBase, clamped to avoid degenerate values. */
    private static double distanceRatio(double repMeters, double seedMeters) {
        double base = (seedMeters <= 0.0) ? 100.0 : seedMeters; // fallback: per-100m baseline
        double r = repMeters / base;
        return Math.max(0.1, r);
    }

    private static double lerp(double a, double b, double t) {
        if (t <= 0) return a;
        if (t >= 1) return b;
        return a + (b - a) * t;
    }

    /** Round seconds to the nearest 5-second boundary (ties round up). */
    private static int roundToNearest5(int secs) {
        int rem = secs % 5;
        if (rem < 0) rem += 5;
        return (rem < 3) ? (secs - rem) : (secs + (5 - rem));
    }

    /**
     * Rest percentage as a function of effort and distance ratio r.
     * Curves chosen from prior notes:
     *  - EASY: ~10% at <=1.0, ~18% by 4.0, taper toward ~5% very long
     *  - ENDURANCE: ~4â€“5% nearly flat
     *  - THRESHOLD: ~6.7% at <=1.0 easing toward ~4% long
     *  - RACE/VO2/SPRINT: ~70% at <=1.0, ~25% by 4.0, ~5% very long
     */
    private static double restPercent(Effort e, double r) {
        if (e == null) return 0.06;

        switch (e) {
            case EASY: {
                if (r <= 1.0) return 0.10;
                if (r <= 4.0) return lerp(0.10, 0.18, (r - 1.0) / 3.0);
                return lerp(0.18, 0.05, Math.min((r - 4.0) / 11.0, 1.0));
            }
            case ENDURANCE: {
                if (r <= 1.0) return 0.04;
                if (r <= 4.0) return lerp(0.04, 0.05, (r - 1.0) / 3.0);
                return lerp(0.05, 0.045, Math.min((r - 4.0) / 11.0, 1.0));
            }
            case THRESHOLD: {
                if (r <= 1.0) return 0.067;
                if (r <= 4.0) return lerp(0.067, 0.055, (r - 1.0) / 3.0);
                return lerp(0.055, 0.040, Math.min((r - 4.0) / 11.0, 1.0));
            }
            case RACE_PACE:
            case VO2_MAX:
            case SPRINT: {
                if (r <= 1.0) return 0.70;
                if (r <= 4.0) return lerp(0.70, 0.25, (r - 1.0) / 3.0);
                return lerp(0.25, 0.05, Math.min((r - 4.0) / 11.0, 1.0));
            }
            default:
                return 0.06;
        }
    }
}package swimworkoutbuilder.model.units;

import java.math.BigDecimal;
import java.util.Objects;

/**
 * Immutable distance with exact internal storage.
 * Canonical unit: 0.0001 meters (1e-4 m, i.e., 0.1 mm) stored as a long.
 * This makes 1 yard = 0.9144 m = 9144 internal units (exact).
 */
public final class Distance implements Comparable<Distance> {

    public enum Unit { METERS, YARDS }

    // 1 internal unit = 0.0001 m
    private static final long UM4_PER_METER = 10_000L;
    private static final long UM4_PER_YARD  = 9_144L; // exact: 0.9144 m * 10_000

    private final long um4;       // canonical value
    private final Unit display;   // how the user entered / prefers to see it

    private Distance(long um4, Unit display) {
        this.um4 = um4;
        this.display = Objects.requireNonNull(display, "display");
    }

    /** Factory: exact when meters has â‰¤4 decimals; otherwise rounds to nearest 0.1 mm. */
    public static Distance ofMeters(double meters) {
        long v = Math.round(meters * UM4_PER_METER);
        return new Distance(v, Unit.METERS);
        // If you need guaranteed no-double path, add a BigDecimal overload.
    }

    /** Factory: exact for any fractional/whole yards (because 1 yd = 9144 um4 exactly). */
    public static Distance ofYards(double yards) {
        long v = Math.round(yards * UM4_PER_YARD);
        return new Distance(v, Unit.YARDS);
    }

    /** Exact factory (canonical). */
    public static Distance ofCanonicalUm4(long um4, Unit display) {
        return new Distance(um4, display);
    }

    /** Canonical raw value (0.0001 m units). */
    public long rawUm4() { return um4; }

    /** Preferred display unit. */
    public Unit displayUnit() { return display; }

    // --------- Conversions (use doubles for UI only; core math should use um4) ---------

    public double toMeters() { return (double) um4 / UM4_PER_METER; }

    public double toYards()  { return (double) um4 / UM4_PER_YARD;  }

    /** Convert to a new Distance with the requested display unit (value unchanged). */
    public Distance withDisplay(Unit unit) {
        if (unit == this.display) return this;
        return new Distance(this.um4, unit);
    }

    // --------- Arithmetic (exact in canonical space) ---------

    public Distance plus(Distance other) {
        return new Distance(Math.addExact(this.um4, other.um4), this.display);
    }

    public Distance minus(Distance other) {
        return new Distance(Math.subtractExact(this.um4, other.um4), this.display);
    }

    public Distance times(int k) {
        return new Distance(Math.multiplyExact(this.um4, k), this.display);
    }

    public Distance times(double factor) {
        // Only use for policy multipliers; rounds to nearest 0.1 mm at the edge.
        long v = Math.round(this.um4 * factor);
        return new Distance(v, this.display);
    }

    // --------- Comparisons / Equality ---------

    @Override public int compareTo(Distance o) { return Long.compare(this.um4, o.um4); }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Distance)) return false;
        Distance d = (Distance) o;
        return um4 == d.um4; // display unit is UI preference; equality is canonical
    }

    @Override public int hashCode() { return Long.hashCode(um4); }

    // --------- Formatting helpers (UI/IO can use these) ---------

    /** Meters as BigDecimal with 4 decimal places (exact). */
    public BigDecimal metersAsBigDecimal() {
        return BigDecimal.valueOf(um4, 4); // scale = 4 decimal places
    }

    /** Yards as BigDecimal (may be repeating; this is for display/rounding at edges). */
    public BigDecimal yardsAsBigDecimal(int scale) {
        return BigDecimal.valueOf(um4)
                .divide(BigDecimal.valueOf(UM4_PER_YARD), scale, java.math.RoundingMode.HALF_UP);
    }

    @Override public String toString() {
        return display == Unit.METERS
                ? metersAsBigDecimal() + " m"
                : yardsAsBigDecimal(2) + " yd";
    }
}package swimworkoutbuilder.model.units;

import java.util.Objects;

/** Immutable time span stored as milliseconds (long). */
public final class TimeSpan implements Comparable<TimeSpan> {
    private final long millis;

    private TimeSpan(long millis) { this.millis = millis; }

    public static TimeSpan ofMillis(long ms) { return new TimeSpan(ms); }

    public static TimeSpan ofSeconds(double seconds) {
        return new TimeSpan(Math.round(seconds * 1000.0));
    }

    public static TimeSpan ofMinutesSecondsMillis(int minutes, int seconds, int millis) {
        long total = Math.addExact(Math.addExact(minutes * 60_000L, seconds * 1_000L), millis);
        return new TimeSpan(total);
    }

    public long toMillis() { return millis; }
    public double toSeconds() { return millis / 1000.0; }

    public TimeSpan plus(TimeSpan other) { return new TimeSpan(Math.addExact(millis, other.millis)); }
    public TimeSpan minus(TimeSpan other) { return new TimeSpan(Math.subtractExact(millis, other.millis)); }
    public TimeSpan times(double factor) { return new TimeSpan(Math.round(millis * factor)); }

    @Override public int compareTo(TimeSpan o) { return Long.compare(this.millis, o.millis); }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof TimeSpan)) return false;
        return millis == ((TimeSpan) o).millis;
    }

    @Override public int hashCode() { return Long.hashCode(millis); }

    /** e.g., 1:23.45 (mm:ss.SS) */
    @Override public String toString() {
        long total = millis;
        long minutes = total / 60_000; total %= 60_000;
        long seconds = total / 1_000;  total %= 1_000;
        long hundredths = Math.round(total / 10.0);
        if (hundredths == 100) { hundredths = 0; seconds++; }
        if (seconds == 60) { seconds = 0; minutes++; }
        return String.format("%d:%02d.%02d", minutes, seconds, hundredths);
    }
}package swimworkoutbuilder.model;

import swimworkoutbuilder.model.units.Distance;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * A logical group of sets (e.g., Warmup, Drills, Main, Cooldown).
 * Holds its sets, optional notes, optional rest after the group, and display order.
 *
 * MVP: container only â€” no timing math here. Distance helpers are provided for convenience.
 */
public class SetGroup {
    private final UUID id;
    private String name;            // label, e.g., "Warmup"
    private int reps;               // how many times this whole group repeats (>=1)
    private int order;              // display / sequence order in the workout
    private final List<SwimSet> sets = new ArrayList<>();
    private int restAfterGroupSec;  // optional rest after the group
    private String notes;           // optional

    // Constructors
    public SetGroup(String name, int reps, int order) {
        if (reps < 1) throw new IllegalArgumentException("Group reps must be >= 1");
        this.id = UUID.randomUUID();
        this.name = name;
        this.reps = reps;
        this.order = order;
    }

    // Getters & Setters
    public UUID getId() { return id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public int getReps() { return reps; }
    public void setReps(int reps) {
        if (reps < 1) throw new IllegalArgumentException("Group reps must be >= 1");
        this.reps = reps;
    }

    public int getOrder() { return order; }
    public void setOrder(int order) { this.order = order; }

    public List<SwimSet> getSets() { return sets; }

    public int getRestAfterGroupSec() { return restAfterGroupSec; }
    public void setRestAfterGroupSec(int restAfterGroupSec) { this.restAfterGroupSec = Math.max(0, restAfterGroupSec); }

    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }

    // Mutators
    public void addSet(SwimSet set) {
        if (set != null) sets.add(set);
    }

    public void removeSet(SwimSet set) {
        sets.remove(set);
    }

    public int getSetCount() {
        return sets.size();
    }

    // ---- Distance helpers (Distance-aware) ----

    /** Sum of all sets' distance for a single pass of the group (exact Distance). */
    public Distance singlePassDistance() {
        long totalUm4 = 0L; // sum in canonical 0.0001 m units
        for (SwimSet s : sets) {
            long perRepUm4 = s.getDistancePerRep().rawUm4();
            totalUm4 = Math.addExact(totalUm4, Math.multiplyExact(perRepUm4, s.getReps()));
        }
        // Totals are generally displayed in meters; choose METERS as display unit.
        return Distance.ofCanonicalUm4(totalUm4, Distance.Unit.METERS);
    }

    /** Total distance including group repeats (exact Distance). */
    public Distance totalDistance() {
        long singleUm4 = singlePassDistance().rawUm4();
        long totalUm4  = Math.multiplyExact(singleUm4, Math.max(1, (long) reps));
        return Distance.ofCanonicalUm4(totalUm4, Distance.Unit.METERS);
    }

    // ---- Legacy meter helpers (kept for compatibility) ----

    /** Sum of all sets' distance for a single pass of the group (meters, rounded). */
    @Deprecated
    public int singlePassDistanceMeters() {
        return (int) Math.round(singlePassDistance().toMeters());
    }

    /** Total distance including group repeats (meters, rounded). */
    @Deprecated
    public int totalDistanceMeters() {
        return (int) Math.round(totalDistance().toMeters());
    }

    @Override
    public String toString() {
        return "SetGroup{" +
                "name='" + name + '\'' +
                ", reps=" + reps +
                ", order=" + order +
                ", sets=" + sets.size() +
                ", restAfterGroupSec=" + restAfterGroupSec +
                (notes != null && !notes.isBlank() ? ", notes='" + notes + '\'' : "") +
                '}';
    }
}package swimworkoutbuilder;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;
import swimworkoutbuilder.model.Workout;
import swimworkoutbuilder.ui.MainViewController;

public class App extends Application {

    private static Workout workoutFromMain; // stash the workout built in Main

    public static void setWorkout(Workout w) {
        workoutFromMain = w;
    }

    @Override
    public void start(Stage stage) throws Exception {
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/ui/MainView.fxml"));
        Parent root = loader.load();   // âœ… cast to Parent

        // hand workout to controller
        MainViewController controller = loader.getController();
        if (workoutFromMain != null) {
            controller.setWorkout(workoutFromMain);
        }

        stage.setTitle("SwimWorkoutBuilder");
        stage.setScene(new Scene(root));
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}